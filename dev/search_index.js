var documenterSearchIndex = {"docs":
[{"location":"developer/#Developer-documentation","page":"Developer","title":"Developer documentation","text":"","category":"section"},{"location":"developer/#Building-the-documentation-locally","page":"Developer","title":"Building the documentation locally","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"If not mentioned otherwise I assume that you are using the bash terminal. On Windows you can install it using this software: Git for Windows . Be careful: The included bash terminal is not fully compatible with the juliaup Julia installer. If you are using juliaup either use the bash terminal from VSCode, or install Windows Terminal.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"To build the documentation locally:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"add the package TestEnv to your global Julia environment  \nusing Pkg\nPkg.add(\"TestEnv\")\ncreate a fork of the QML.jl repository by going to QML.jl and","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"clicking on the button \"Fork\" on the top right","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"check it out locally using git, e.g. with the command  \ngit clone https://github.com/USERNAME/QML.jl.git\nwhere USERNAME is your github user name.\nnavigate to the new folder QML.jl folder and start julia with julia --project\ninstantiate the project with\nusing Pkg\nPkg.instantiate()\nactivate the test environment with\nusing TestEnv; TestEnv.activate()\nnow you can build and view the documentation with\nusing LiveServer\nservedocs()","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"And click on the link http://localhost:8080 to see the documentation.","category":"page"},{"location":"developer/#Contributing","page":"Developer","title":"Contributing","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"We need more people who help with improving the documentation, fixing bugs and with keeping the package up-to-date. You can see open documentation issues here, open bugs here, and there are of course also open feature requests and ideas to create a new add-on packages, e.g.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"a package for improved Makie integration\na package for improved GR integration\na package for displaying and editing DataFrames","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"You can get in touch with the current developers either on Discourse or via JuliaGraphics. ","category":"page"},{"location":"developer/#Creating-a-pull-request","page":"Developer","title":"Creating a pull request","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"If you made changes to the documentation (or any change to the code), please push these changes to your fork and then create a pull request by clicking on the \"Contribute\" button on the github page of your fork. Before doing that make sure your fork is in sync with the main branch of QML.jl.","category":"page"},{"location":"developer/#Related-packages","page":"Developer","title":"Related packages","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Some changes to QML.jl might require changes to one or more of the following, related packages:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"https://github.com/barche/QmlJuliaExamples   Changes to QML.jl might require changes to the examples. Furthermore, when running the QML tests also these examples are executed, so changes to the examples might even brake these tests.\nhttps://github.com/JuliaGraphics/jlqml This is the C++ interface package that glues Julia with the QT libraries.\nhttps://github.com/JuliaBinaryWrappers/Qt6Wayland_jll.jl   The only direct dependency on a (binary) jll package. There are many more indirect binary dependencies, mainly for the QT packages.","category":"page"},{"location":"#QML","page":"QML","title":"QML","text":"","category":"section"},{"location":"#Loading","page":"QML","title":"Loading","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"We support three methods of loading a QML file: QML.QQmlApplicationEngine, QML.QQuickView and QQmlComponent. These behave equivalently to the corresponding Qt classes. They have different advantages:","category":"page"},{"location":"","page":"QML","title":"QML","text":"You can simply load a QML file using the loadqml function as a QML.QQmlApplicationEngine.\nQML.QQuickView creates a window, so it's not necessary to wrap the QML in ApplicationWindow.\nYou can run QML code contained in a string with QQmlComponent.","category":"page"},{"location":"#QML-modules","page":"QML","title":"QML modules","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Since QML.jl version 0.2, only the QtDeclarative package is installed by default, which includes only a very limited set of QML modules.","category":"page"},{"location":"#Interaction","page":"QML","title":"Interaction","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Interaction with Julia happens through the following mechanisms:","category":"page"},{"location":"","page":"QML","title":"QML","text":"Call Julia functions from QML, e.g. with @qmlfunction.\nRead and set context properties from Julia and QML, e.g. with keywords to loadqml or set_context_property.\nEmit signals from Julia to QML, e.g. with @emit.\nUse data models, e.g. JuliaItemModel or JuliaPropertyMap.","category":"page"},{"location":"","page":"QML","title":"QML","text":"Note that Julia slots appear missing, but they are not needed since it is possible to directly connect a Julia function to a QML signal in the QML code, e.g. with QTimer.","category":"page"},{"location":"#Type-conversion","page":"QML","title":"Type conversion","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Most fundamental types are converted implicitly. Mind that the default integer type in QML corresponds to Int32 in Julia.","category":"page"},{"location":"","page":"QML","title":"QML","text":"We also convert QVariantMap, exposing the indexing operator [] to access element by a string key. This mostly to deal with arguments passed to the QML append function in list models.","category":"page"},{"location":"#Interface","page":"QML","title":"Interface","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Modules = [QML]","category":"page"},{"location":"","page":"QML","title":"QML","text":"Modules = [QML]","category":"page"},{"location":"#QML.QML","page":"QML","title":"QML.QML","text":"Module for building Qt6 QML graphical user interfaces for Julia programs. Types starting with Q are equivalent of their Qt C++ counterpart, so, unless otherwise noted, they have no Julia docstring and we refer to the Qt documentation for details instead.\n\n\n\n\n\n","category":"module"},{"location":"#QML.JuliaDisplay","page":"QML","title":"QML.JuliaDisplay","text":"struct JuliaDisplay\n\nYou can use display to send images to a JuliaDisplay. There is a corresponding QML block called JuliaDisplay. Of course the display can also be added using pushdisplay!, but passing by value can be more convenient when defining multiple displays in QML. See below for syntax.\n\njulia> using QML\n\njulia> using Colors\n\njulia> function simple_image(julia_display::JuliaDisplay)\n          display(julia_display, Gray.(rand(50,50)))\n          nothing\n        end;\n\njulia> @qmlfunction simple_image\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          import QtQuick.Layouts\n          import org.julialang\n          ApplicationWindow {\n            visible: true\n            JuliaDisplay {\n              id: julia_display\n              width: 50\n              height: 50\n              Component.onCompleted: {\n                Julia.simple_image(julia_display)\n              }\n            }\n            Timer {\n              interval: 2000; running: true; repeat: false\n              onTriggered: Qt.exit(0)\n            }\n          }\n          \"\"\")\n          loadqml(path)\n          exec()\n        end;\n\n\n\n\n\n\n","category":"type"},{"location":"#QML.JuliaItemModel-Union{Tuple{DataT}, Tuple{DataT, Any}} where DataT","page":"QML","title":"QML.JuliaItemModel","text":"function JuliaItemModel(items::AbstractVector, addroles::Bool = true)\n\nConstructor for a JuliaItemModel. The JuliaItemModel type allows using data in QML views such as ListView and Repeater, providing a two-way synchronization of the data. A JuliaItemModel is constructed from a 1D Julia array. To use the model from QML, it can be exposed as a context attribute.\n\nSetter and getter \"roles\" based on the fieldnames of the eltype will be automatically created if addroles is true.\n\nIn Qt, each of the elements of a model has a series of roles, available as properties in the delegate that is used to display each item. The roles can be added using the addrole! function.\n\njulia> using QML\n\njulia> mutable struct Fruit\n          name::String\n          cost::Float64\n        end\n\njulia> fruits = JuliaItemModel([Fruit(\"apple\", 1.0), Fruit(\"orange\", 2.0)]);\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          import QtQuick.Layouts\n          ApplicationWindow {\n            visible: true\n            ListView {\n              model: fruits\n              anchors.fill: parent\n              delegate:\n                Row {\n                  Text {\n                    text: name\n                  }\n                  Button {\n                    text: \"Sale\"\n                    onClicked: cost = cost / 2\n                  }\n                  Button {\n                    text: \"Duplicate\"\n                    onClicked: fruits.appendRow({\"name\": name, \"cost\": cost})\n                  }\n                  Timer {\n                    running: true; repeat: false\n                    onTriggered: Qt.exit(0)\n                  }\n                }\n              }\n            }\n          \"\"\")\n          loadqml(path; fruits)\n          exec()\n        end\n\n\n\n\n\n","category":"method"},{"location":"#QML.JuliaPropertyMap-Tuple{Vararg{Pair{<:AbstractString}}}","page":"QML","title":"QML.JuliaPropertyMap","text":"function JuliaPropertyMap(pairs...)\n\nStore Julia values for access from QML. Observables are connected so they change on the QML side when updated from Julia and vice versa only when passed in a property map. Note that in the example below, if you run output[] = new_value from within Julia, the slider in QML will move.\n\njulia> using QML\n\njulia> using Observables: Observable, on\n\njulia> output = Observable(0.0);\n\njulia> on(println, output);\n\njulia> mktempdir() do folder\n         path = joinpath(folder, \"main.qml\")\n         write(path, \"\"\"\n         import QtQuick\n         import QtQuick.Controls\n         ApplicationWindow {\n           visible: true\n           Slider {\n             onValueChanged: {\n               observables.output = value;\n             }\n           }\n           Timer {\n             running: true; repeat: false\n             onTriggered: Qt.exit(0)\n           }\n         }\n         \"\"\")\n         loadqml(path; observables = JuliaPropertyMap(\"output\" => output))\n         exec()\n       end\n\n\n\n\n\n","category":"method"},{"location":"#QML.QByteArray","page":"QML","title":"QML.QByteArray","text":"function QByteArray(a_string::String)\n\nUse to pass text to set_data.\n\n\n\n\n\n","category":"type"},{"location":"#QML.QQmlApplicationEngine","page":"QML","title":"QML.QQmlApplicationEngine","text":"struct QQmlApplicationEngine\n\nOne of 3 ways to interact with QML (the others being QQuickView and QQmlComponent. You can load a QML file to create an engine with [load]. Use exec to execute a file after it's been loaded.\n\nThe lifetime of the QQmlApplicationEngine is managed from C++ and it gets cleaned up when the application  quits. This means it is not necessary to keep a reference to the engine to prevent it from being garbage collected prematurely.\n\njulia> using QML\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          ApplicationWindow {\n            visible: true\n            Text {\n              text: greeting\n            }\n            Timer {\n              running: true; repeat: false\n              onTriggered: Qt.exit(0)\n            }\n          }\n          \"\"\")\n          loadqml(path; greeting = \"Hello, World!\")\n          exec()\n        end\n\n\n\n\n\n","category":"type"},{"location":"#QML.QQmlComponent","page":"QML","title":"QML.QQmlComponent","text":"struct QQmlComponent\n\nOne of 3 ways to interact with QML (the others being QQmlApplicationEngine and QQuickView. Make from an engine from e.g.init_qmlengine. Use set_data to set the QML code, create to create the window, and exec to fill the window.\n\njulia> using QML\n\njulia> component = QQmlComponent(init_qmlengine());\n\njulia> set_data(component, QByteArray(\"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          ApplicationWindow {\n            visible: true\n            Rectangle {\n              Text {\n                text: \"Hello, World!\"\n              }\n              Timer {\n                running: true; repeat: false\n                onTriggered: Qt.exit(0)\n              }\n            }\n          }\n        \"\"\"), QUrl())\n\njulia> create(component, qmlcontext())\n\njulia> exec()\n\n\n\n\n\n","category":"type"},{"location":"#QML.QQuickView","page":"QML","title":"QML.QQuickView","text":"struct QQuickView\n\nOne of 3 ways to interact with QML (the others being QQmlApplicationEngine and QQmlComponent. QQuickView creates a window, so it's not necessary to wrap the QML in ApplicationWindow. Use init_qquickview to create a quick view, set_source to set the source for the quick view, QML.show to view, and exec to execute.\n\njulia> using QML\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          Rectangle {\n            Text {\n              text: \"Hello, World!\"\n            }\n            Timer {\n              running: true; repeat: false\n              onTriggered: parent.Window.window.close()\n            }\n          }\n          \"\"\")\n          quick_view = init_qquickview()\n          set_source(quick_view, QUrlFromLocalFile(path))\n          QML.show(quick_view)\n          exec()\n        end\n\n\n\n\n\n","category":"type"},{"location":"#QML.QTimer","page":"QML","title":"QML.QTimer","text":"struct QTimer\n\nYou can use QTimer to simulate running Julia in the background. Note that QML provides the infrastructure to connect to the QTimer signal through the Connections item.\n\njulia> using QML\n\njulia> counter = Ref(0);\n\njulia> increment() = counter[] += 1;\n\njulia> @qmlfunction increment\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          import org.julialang\n          ApplicationWindow {\n              visible: true\n              Connections {\n                target: timer\n                function onTimeout() {\n                  Julia.increment()\n                }\n              }\n              Button {\n                  text: \"Start counting\"\n                  onClicked: timer.start()\n              }\n              Timer { // unrelated, this is a timer to stop and continue testing\n                running: true; repeat: false\n                onTriggered: Qt.exit(0)\n              }\n          }\n          \"\"\")\n          loadqml(path, timer=QTimer())\n          exec()\n        end\n\n\n\n\n\n","category":"type"},{"location":"#QML.QUrl","page":"QML","title":"QML.QUrl","text":"struct QUrl([filename::String])\n\nUsed to pass filenames to set_source. Pass an empty url (no arguments) to set_data.\n\n\n\n\n\n","category":"type"},{"location":"#Base.string","page":"QML","title":"Base.string","text":"function string(data::QByteArray)\n\nEquivalent to QByteArray::toString. Use to convert a QByteArray back to a string.\n\njulia> using QML\n\njulia> string(QByteArray(\"Hello, World!\"))\n\"Hello, World!\"\n\n\n\n\n\n","category":"function"},{"location":"#QML.addrole!","page":"QML","title":"QML.addrole!","text":"function addrole!(model::JuliaItemModel, name::String, getter, [setter])\n\nAdd your own getter (and optionally, setter) functions to a JuliaItemModel for use by QML. setter is optional, and if it is not provided the role will be read-only. getter will process an item before it is returned. The arguments of setter will be collection, new_value, index as in the standard setindex! function. If you would like to see the roles defined for a list, use roles.\n\njulia> using QML\n\njulia> items = [\"A\", \"B\"];\n\njulia> array_model = JuliaItemModel(items, false);\n\njulia> addrole!(array_model, \"item\", identity, setindex!)\n\njulia> roles(array_model)[256]\n\"item\"\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          import QtQuick.Layouts\n          ApplicationWindow {\n            visible: true\n            ListView {\n              model: array_model\n              anchors.fill: parent\n              delegate: TextField {\n                placeholderText: item\n                onTextChanged: item = text;\n              }\n            }\n            Timer {\n              running: true; repeat: false\n              onTriggered: Qt.exit(0)\n            }\n          }\n          \"\"\")\n          loadqml(path; array_model = array_model)\n          exec()\n        end\n\n\n\n\n\n","category":"function"},{"location":"#QML.content_item","page":"QML","title":"QML.content_item","text":"function content_item(quick_view::QQuickView)\n\nGet the content item of a quick view. Equivalent to QQuickWindow::contentItem.\n\njulia> using QML\n\njulia> using CxxWrap.CxxWrapCore: CxxPtr\n\njulia> quick_view = mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          Rectangle {\n            Timer {\n              running: true; repeat: false\n              onTriggered: Qt.exit(0)\n            }\n          }\n          \"\"\")\n          quick_view = init_qquickview()\n          set_source(quick_view, QUrlFromLocalFile(path))\n          @assert content_item(quick_view) isa CxxPtr{QQuickItem}\n          exec()\n        end\n\n\n\n\n\n","category":"function"},{"location":"#QML.context_property","page":"QML","title":"QML.context_property","text":"function context_property(context::QQmlContext, item::AbstractString)\n\nGet a context property. See the example for root_context.\n\n\n\n\n\n","category":"function"},{"location":"#QML.create","page":"QML","title":"QML.create","text":"function create(component::QQmlComponent, context::QQmlContext)\n\nEquivalent to QQmlComponent::create. This creates a component defined by the QML code set using set_data. It also makes sure the newly created object is parented to the given context. See the example for set_data.\n\n\n\n\n\n","category":"function"},{"location":"#QML.engine","page":"QML","title":"QML.engine","text":"function engine(quick_view::QQuickView)\n\nEquivalent to QQuickView::engine. If you would like to modify the context of a QQuickView, use engine to get an engine from the window, and then root_context to get the context from the engine.\n\njulia> using QML\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          Rectangle {\n            Text {\n              text: greeting\n            }\n            Timer {\n              running: true; repeat: false\n              onTriggered: parent.Window.window.close()\n            }\n          }\n          \"\"\")\n          quick_view = init_qquickview()\n          context = root_context(engine(quick_view))\n          set_context_property(context, \"greeting\", \"Hello, World!\")\n          set_source(quick_view, QUrlFromLocalFile(path))\n          QML.show(quick_view)\n          exec()\n        end\n\n\n\n\n\n","category":"function"},{"location":"#QML.exec","page":"QML","title":"QML.exec","text":"function exec()\n\nFill out a window. Use with a QQmlApplicationEngine, QQuickView, or QQmlComponent. Note that after calling exec, you will need to reregister functions, e.g. with [@qmlfunction], if you want to exec again.\n\n\n\n\n\n","category":"function"},{"location":"#QML.exec_async","page":"QML","title":"QML.exec_async","text":"function exec_async()\n\nSimilar to exec, but will not block the main process. This method keeps the REPL active and polls the QML interface periodically for events, using a timer in the Julia event loop.\n\n\n\n\n\n","category":"function"},{"location":"#QML.init_qmlengine","page":"QML","title":"QML.init_qmlengine","text":"function init_qmlengine()\n\nCreate a QML engine. You can modify the context of an engine using root_context. You can use an engine to create QQmlComponents. See the example for set_data. Note that you can also get the engine for a QQuickView using engine.\n\n\n\n\n\n","category":"function"},{"location":"#QML.init_qquickview","page":"QML","title":"QML.init_qquickview","text":"function init_qquickview()\n\nCreate a QQuickView.\n\n\n\n\n\n","category":"function"},{"location":"#QML.loadqml-Tuple{Any}","page":"QML","title":"QML.loadqml","text":"function loadqml(qmlfilename; properties...)\n\nLoad a QML file, creating a QML.QQmlApplicationEngine, and setting the context properties supplied in the keyword arguments. Will create and return a QQmlApplicationEngine. See the example for QML.QQmlApplicationEngine.\n\n\n\n\n\n","category":"method"},{"location":"#QML.qmlcontext","page":"QML","title":"QML.qmlcontext","text":"function qmlcontext()\n\nCreate an empty context for QML. Required for create.\n\n\n\n\n\n","category":"function"},{"location":"#QML.qmlfunction","page":"QML","title":"QML.qmlfunction","text":"function qmlfunction(function_name::String, a_function)\n\nRegister a_function using function_name. If you want to register a function under it's own name, you can use @qmlfunction. Note, however, that you can't use the macro for registering functions from a non-exported module or registering functions wtih ! in the name.\n\n\n\n\n\n","category":"function"},{"location":"#QML.qt_prefix_path","page":"QML","title":"QML.qt_prefix_path","text":"function qt_prefix_path()\n\nEquivalent to QLibraryInfo::location(QLibraryInfo::PrefixPath). Useful to check whether the intended Qt version is being used.\n\njulia> using QML\n\njulia> isdir(qt_prefix_path())\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#QML.roles-Tuple{JuliaItemModel}","page":"QML","title":"QML.roles","text":"function roles(model::JuliaItemModel)\n\nSee all roles defined for a JuliaItemModel. See the example for addrole!.\n\n\n\n\n\n","category":"method"},{"location":"#QML.root_context","page":"QML","title":"QML.root_context","text":"root_context(an_engine::QQmlEngine)\n\nGet the context of an_engine. Equivalent to QQmlEngine::rootContext. Use set_context_property to modify the context. Use context_property to get a particular property. Use to get the context of an engine created with init_qmlengine before using set_data or from engine.\n\njulia> using QML\n\njulia> an_engine = init_qmlengine();\n\njulia> context = root_context(an_engine);\n\njulia> set_context_property(context, \"greeting\", \"Hello, World!\");\n\njulia> context_property(context, \"greeting\")\nQVariant of type QString with value Hello, World!\n\njulia> component = QQmlComponent(an_engine);\n\njulia> set_data(component, QByteArray(\"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          ApplicationWindow {\n            visible: true\n            Rectangle {\n              Text {\n                text: greeting\n              }\n              Timer {\n                running: true; repeat: false\n                onTriggered: Qt.exit(0)\n              }\n            }\n          }\n        \"\"\"), QUrl())\n\njulia> create(component, qmlcontext())\n\njulia> exec()\n\n\n\n\n\n","category":"function"},{"location":"#QML.set_context_property","page":"QML","title":"QML.set_context_property","text":"set_context_property(context::QQmlContext, name::String, value::Any)\n\nSet properties. See root_context for an example.\n\n\n\n\n\n","category":"function"},{"location":"#QML.set_data","page":"QML","title":"QML.set_data","text":"function set_data(component::QQmlComponent, data::QByteArray, file::QUrl)\n\nEquivalent to QQmlComponent::setData. Use this to set the QML code for a QQmlComponent from a Julia string literal wrapped in a QByteArray. Also requires an empty QUrl. See QQmlComponent for an example.\n\n\n\n\n\n","category":"function"},{"location":"#QML.set_source","page":"QML","title":"QML.set_source","text":"function set_source(window::QQuickView, file::QUrl)\n\nEquivalent to QQuickView::setSource. See the example for init_qquickview. The file path should be a path wrapped with QUrl.\n\n\n\n\n\n","category":"function"},{"location":"#QML.setheadergetter!-Tuple{JuliaItemModel, Function}","page":"QML","title":"QML.setheadergetter!","text":"setheadergetter!(itemmodel::JuliaItemModel, f::Function)\n\nSet f as function to call when getting header data. The signature of of should be:\n\n  f(data, row_or_col, orientation, role)\n\nHere, data is the internal data array stored in the model, row_or_col is the index of the row or column, orientation is either QML.Horizontal for column headers or QML.Vertical for row headers and role is an integer describing the role (e.g. QML.DisplayRole) \n\n\n\n\n\n","category":"method"},{"location":"#QML.setheadersetter!-Tuple{JuliaItemModel, Function}","page":"QML","title":"QML.setheadersetter!","text":"setheadersetter!(itemmodel::JuliaItemModel, f::Function)\n\nSet f as function to call when setting header data. The signature of of should be:\n\n  f(data, row_or_col, orientation, value, role)\n\nHere, value is the value for the given header item. The other arguments are the same as in setheadergetter! \n\n\n\n\n\n","category":"method"},{"location":"#QML.show","page":"QML","title":"QML.show","text":" function QML.show()\n\nEquivalent to QQuickView::show. See example for QQuickView.\n\n\n\n\n\n","category":"function"},{"location":"#QML.@emit-Tuple{Any}","page":"QML","title":"QML.@emit","text":"@emit signal_name(arguments...)\n\nEmit a signal from Julia to QML. Handle signals in QML using a JuliaSignals block. See the example below for syntax.\n\nwarning: Warning\nThere must never be more than one JuliaSignals block in QML\n\njulia> using QML\n\njulia> duplicate(value) = @emit duplicateSignal(value);\n\njulia> @qmlfunction duplicate\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick\n          import QtQuick.Controls\n          import QtQuick.Layouts\n          import org.julialang\n          ApplicationWindow {\n              visible: true\n              Column {\n                TextField {\n                    id: input\n                    onTextChanged: Julia.duplicate(text)\n                }\n                Text {\n                    id: output\n                }\n                JuliaSignals {\n                  signal duplicateSignal(var value)\n                  onDuplicateSignal: output.text = value\n                }\n                Timer {\n                  running: true; repeat: false\n                  onTriggered: Qt.exit(0)\n                }\n              }\n          }\n          \"\"\")\n          loadqml(path)\n          exec()\n        end\n\n\n\n\n\n","category":"macro"},{"location":"#QML.@expand_dots-Tuple{Any, Any}","page":"QML","title":"QML.@expand_dots","text":"QML.@expand_dots object_.field_ func\n\nExpand an expression of the form a.b.c to replace the dot operator by function calls.\n\njulia> using QML\n\njulia> @macroexpand QML.@expand_dots a.b.c.d f\n:(f(f(f(a, \"b\"), \"c\"), \"d\"))\n\n\n\n\n\n","category":"macro"},{"location":"#QML.@qmlfunction-Tuple","page":"QML","title":"QML.@qmlfunction","text":"@qmlfunction function_names...\n\nRegister Julia functions for access from QML under their own name. Function names must be valid in QML, e.g. they can't contain !. You can use your newly registered functions in QML by first importing org.julialang 1.0, and then calling them with Julia.function_name(arguments...). If you would like to register a function under a different name, use qmlfunction. This will be necessary for non-exported functions from a different module or in case the function contains a ! character.\n\njulia> using QML\n\njulia> greet() = \"Hello, World!\";\n\njulia> @qmlfunction greet\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import org.julialang\n          import QtQuick\n          import QtQuick.Controls\n          ApplicationWindow {\n            visible: true\n            Text {\n              text: Julia.greet()\n            }\n            Timer {\n              running: true; repeat: false\n              onTriggered: Qt.exit(0)\n            }\n          }\n          \"\"\")\n          loadqml(path)\n          exec()\n        end\n\n\n\n\n\n","category":"macro"}]
}
